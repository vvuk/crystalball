"use strict";
const importData = require('./import-data.js');
const sift = require('sift');
const es = require('event-stream');
const cmdline = require('command-line-args');
const jsonfile = require('jsonfile');
const weight = require('./weight.js');

let topCrashes = {};
let buckets = null;
let channelSelector = null;
let verbose = false;

function doQueries(recs) {
  if (buckets) {
    for (let bucket of buckets) {
      let matched = recs.filter(bucket._sifter);
      for (let m of matched) {
        if (channelSelector && m['channel'] != channelSelector)
          continue;

        let w = bucket._weight;
        let sig = m['signature'];

        if (sig in topCrashes) {
          topCrashes[sig] += w;
        } else {
          topCrashes[sig] = w;
        }
      }
    }
  }

  for (let rec of recs) {
    if (channelSelector && rec['channel'] != channelSelector)
      continue;

    let sig = rec['signature'];
    let w = rec._weight;
    if (buckets) {
      if (!w)
        continue;
    } else {
      w = 1;
    }

    if (sig in topCrashes) {
      topCrashes[sig] += w;
    } else {
      topCrashes[sig] = w;
    }
  }
}

function printReport() {
  let crashArray = [];
  for (let sig in topCrashes) {
    crashArray.push({"sig": sig, "count": topCrashes[sig]});
  }

  crashArray.sort(function(a, b) {
    return b.count - a.count;
  });

  for (let i = 0; i < 15; ++i) {
    console.log(crashArray[i].count.toFixed(2), crashArray[i].sig);
  }
}

let recordCount = 0;
let records = [];
const NUM_RECORDS = 5000;

let handlingStream = es.mapSync(
  function (d) {
    if (recordCount > 0 && (recordCount % NUM_RECORDS) == 0) {
      doQueries(records);
      records = [];
    }
    records.push(d);
    recordCount++;
  });
handlingStream.on('end', function() {
  doQueries(records);
  printReport();
});

if (require.main == module) {
  let cli = cmdline([
    // the bucket module
    { name: 'buckets', alias: 'b', type: String },
    // the bucket counts file, as generated by bucket-counts.json
    { name: 'bucketcounts', alias: 'f', type: String },
    // the channel to show topcrash list for
    { name: 'channel', alias: 'c', type: String },
    // the channel to use as a population map; e.g. channel beta, mapchannel release to show beta
    // topcrashes as if they were happening on release
    { name: 'mapchannel', alias: 'm', type: String },
    // weight file, to use instead of mapchannel
    { name: 'weights', alias: 'w', type: String },
    { name: 'verbose', alias: 'v', type: Boolean },
    { name: 'src', ailas: 's', type: String, multiple: true, defaultOption: true }
  ]);

  const opts = cli.parse();
  let args = opts["src"];
  channelSelector = opts["channel"];
  verbose = opts["verbose"];

  let bucketModule = opts["buckets"];
  if (bucketModule) {
    if (bucketModule.indexOf("/") == -1) {
      bucketModule = "./" + bucketModule;
    }
  }

  if (!args || args.length == 0) {
    args = ["2016-01-01"];
  }

  if (bucketModule) {
    buckets = require(bucketModule).buckets;

    let weightsByName = null;
    let weightData = null;
    if (opts['bucketcounts'] && opts['mapchannel']) {
      let bucketCountData = jsonfile.readFileSync(opts['bucketcounts']);
      weightData = weight.makeWeights(bucketCountData, opts['mapchannel'], bucketCountData, opts['channel']);
    } else if (opts['bucketcounts'] && opts['weights']) {
      weightData = jsonfile.readFileSync(opts['weights']);
    }

    if (weightData) {
      weightsByName = {};
      for (let w of weightData) {
        weightsByName[w['name']] = w['weight'];
        if (verbose) {
          console.log("Weight", w.weight.toFixed(3), w.name);
        }
      }
    }

    for (let bucket of buckets) {
      if (!bucket._sifter) {
        bucket._sifter = sift(bucket.query);
      }
      if (weightsByName) {
        if (!(bucket['name'] in weightsByName)) {
          throw new Error("Can't find weight for bucket " + bucket['name']);
        }

        bucket._weight = weightsByName[bucket['name']];
      } else {
        bucket._weight = 1;
      }
    }
  }

  importData.loadAllData(args, handlingStream);
}

